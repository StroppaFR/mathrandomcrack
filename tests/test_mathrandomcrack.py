import math
import logging
import unittest

from mathrandomcrack.mathrandomcrack import *

logging.basicConfig(level=logging.ERROR)

class TestMathRandomCrack(unittest.TestCase):

    def test_recover_state_from_math_random_doubles(self):
        known_doubles = [0.3729983038966259, 0.17496511670650206, 0.49159038738927563, 0.9421448261165485]

        expected_next = [0.4169322132746547, 0.41772567549954465, 0.49987429368004344, 0.900351160894732, 0.11675650086754474, 0.9835730792649936, 0.4365143224561563, 0.24710079059446166, 0.6719745383456214, 0.41875075942525675, 0.3369734964621547, 0.5641798587145327, 0.5698155574264084, 0.17847408913260177, 0.2649428843215077, 0.380905874015373, 0.263420627102946, 0.32492249540981777, 0.9309357395692637, 0.5356031900205944, 0.858467905098631, 0.5925762380556829, 0.9099143317573467, 0.7238843171279742, 0.1416869712519344, 0.40059256348574523, 0.5622142316529446, 0.918747664580273, 0.633638951418691, 0.44294502976453964, 0.9771591618000606, 0.9692850650182503, 0.422754219845198, 0.9473761797962288, 0.2623898822732029, 0.8311024184508644, 0.043959690564190135, 0.7404585341229147, 0.9774674535534883, 0.17526631589064878, 0.21099720937227284, 0.976079331357949, 0.8177470111768766, 0.7017129189715279, 0.031555940805606975, 0.1930326870018687, 0.30491143066350623, 0.6194209912616457, 0.06324300201261768, 0.306828230704714, 0.9014431675257254, 0.41868001999319804, 0.23319336322434547, 0.5845150673976428, 0.5367912237911235, 0.9882154316624128, 0.9075833101666309, 0.7473239507459919, 0.5406684714524379, 0.3363948330011409, 0.901320127203257, 0.9732303961735218, 0.6455133831352127, 0.7576268453085985, 0.5647368375815475, 0.4659615932762906, 0.5354022303576509, 0.4970983867987443, 0.9278258214841121, 0.9992673904846235, 0.9749618674924401, 0.1584823349451927, 0.9622199718454659, 0.5518860013949756, 0.471320273216671, 0.4184169317544604, 0.8670524127119378, 0.46155628597384446, 0.9087864474745928, 0.7893797553155282, 0.44237307624597033, 0.852150843037217, 0.07301482262959291, 0.5925095524749455, 0.42446481143695325, 0.341532429872783, 0.0014043131869174719, 0.05474809985287277, 0.8244937496746325, 0.9139707334842332, 0.9286557246660236, 0.36527721294136073, 0.34896468064704866, 0.2046638953973562, 0.269845981219898, 0.2051722137082952, 0.6240641988408253, 0.801941203900811, 0.339711548982112, 0.8676256265747037]

        found_correct_state = False
        for recovered_math_random in recover_state_from_math_random_doubles(known_doubles):
            # Verify that the state generates the correct doubles
            for d in known_doubles:
                self.assertEqual(recovered_math_random.next(), d)
            # Check if it generates the expected next doubles
            found_correct_state = all(d == recovered_math_random.next() for d in expected_next)
            if found_correct_state:
                break
        self.assertTrue(found_correct_state)

    def test_recover_state_from_math_random_doubles_scattered(self):
        generated_doubles = [0.28312656309821627, 0.2126296311778575, 0.045291001697600364, 0.9069011015169577, 0.5988258696130254, 0.8028144523905971, 0.2993948573359255, 0.7836084709175235, 0.36330960376322163, 0.5966969790645456]

        # Assume we only know some of the generated values and their position
        positions = [0, 4, 5, 9]
        known_doubles = [generated_doubles[pos] for pos in positions]

        expected_next = [0.918783805780444, 0.5377492878426327, 0.9505629026182582, 0.41944301946452134, 0.06084535675857783, 0.15405402717717143, 0.1546677423098145, 0.042852644838147325, 0.9322033840087246, 0.5480142124404163, 0.6700505956070484, 0.8312332569792561, 0.8029383061489065, 0.25026063311081703, 0.46235894959165325, 0.548745003628291, 0.42810673627480333, 0.1561269490438607, 0.013655815770782787, 0.9518497992055682, 0.3651092861058074, 0.16883307969569128, 0.49229622272914797, 0.05156783389272701, 0.21131101491653004, 0.28408818858209817, 0.3214689702318726, 0.12225616245616666, 0.2598736358356091, 0.8070402831383899, 0.05280059650468172, 0.7253832196232776, 0.9846244194320897, 0.8754534301105803, 0.418982918984675, 0.5861760514383587, 0.5347172569864876, 0.5327400670161115, 0.03400993729608859, 0.1202737829285383, 0.3406961268218863, 0.8883879978982208, 0.032780973354808784, 0.28472216609731704, 0.271036866072481, 0.9905706569974092, 0.13309724391422573, 0.31259746081681783, 0.008206300461536586, 0.14454751793269416, 0.41075733967529315, 0.8464258408804377, 0.04984268419886628, 0.2708405932508332, 0.03584805164928184, 0.9192499700789711, 0.7812702853689516, 0.24376989771012858, 0.2742573843918321, 0.4408069888787156, 0.3579580100744746, 0.4806862252113273, 0.9488107945220575, 0.8215923736436783, 0.3988689513261501, 0.06528325610562502, 0.6498468895265944, 0.11432047732247153, 0.7383617665021109, 0.6107634321359064, 0.3395634254885117, 0.06751690618683925, 0.020233781330262213, 0.16096845144775407, 0.26125412386802893, 0.07147961556802096, 0.9499834345765892, 0.11393201180309231, 0.0265812765988499, 0.5103476761188042, 0.10961313192089339, 0.14364477732321845, 0.6575009304135266, 0.033323587885655814, 0.7847446688452391, 0.9416600696024611, 0.19665670938707347, 0.9113186793492043, 0.3410601077410782, 0.2635955798782108, 0.23524393516288966, 0.2923567544600475, 0.21431544432253602, 0.662795404740445, 0.9045701589788158, 0.7546370695688394, 0.7148389295938502, 0.49036908631505527, 0.993659282611439, 0.2330635451997748]
        
        found_correct_state = False
        for recovered_math_random in recover_state_from_math_random_doubles(known_doubles, positions):
            # Verify that the state generates the correct doubles
            for d in generated_doubles:
                self.assertEqual(recovered_math_random.next(), d)
            # Check if it generates the expected next doubles
            found_correct_state = all(d == recovered_math_random.next() for d in expected_next)
            if found_correct_state:
                break
        self.assertTrue(found_correct_state)

    def test_recover_state_from_math_random_scaled_values(self):
        factor = 36
        translation = 1
        known_values = [17, 17, 24, 30, 24, 6, 32, 29, 9, 36, 26, 12, 34, 5, 3, 28, 26, 8, 29, 32, 19, 21, 27, 10, 31, 28, 19, 6, 1, 6, 33, 36, 18, 23, 33, 21, 32, 33, 36]

        expected_next = [0.4218129454423729, 0.45160340069398586, 0.2808396068917298, 0.11752035209172385, 0.5407210381751475, 0.5996593302014471, 0.7971148341317318, 0.7493914264865006, 0.22021416366697522, 0.595437422353347, 0.5158823896816561, 0.8012747547437711, 0.1456076411816951, 0.7750987028893456, 0.8528656035182629, 0.7915830419453418, 0.9562241901791876, 0.13307286635832816, 0.9811023405348873, 0.8805682376821508, 0.5670978480051219, 0.06357006730036352, 0.7901076428521345, 0.9075551267446471, 0.24417973895373257, 0.030191638241039653, 0.9439447860321662, 0.5638874053373243, 0.2468666279713092, 0.00048764770310028016, 0.2392902385607587, 0.7608255146055712, 0.5300686919176696, 0.07907036751969942, 0.9792668117408088, 0.9935717661101162, 0.8720538447767797, 0.48916916380121944, 0.6935281844627795, 0.09409664043040245, 0.11846729731436878, 0.7914575100178245, 0.5643580279839011, 0.8148564745196389, 0.9374661068983167, 0.11457063360142794, 0.3764500110232335, 0.04760222935159042, 0.7244870462589171, 0.052657570753572136, 0.17701549519135484, 0.015289561706595789, 0.5731095951300582, 0.6842799477489889, 0.35628955377321725, 0.01786445851674956, 0.9529863206295178, 0.3872798179519642, 0.14590307583332707, 0.7203173628581008, 0.8364441744600604, 0.5561381429882156, 0.20527212924707472, 0.3711839792487389, 0.636410449345258, 0.6666483093416258, 0.6993914522643667, 0.0697141925245518, 0.7599196882689709, 0.20143662428724363, 0.5196496788939513, 0.2266112028554612, 0.1934832998316791, 0.7231498596583112, 0.7306447269575812, 0.8487982579409244, 0.3900265701116067, 0.4127085000309396, 0.6780834979898586, 0.7374232378606689, 0.014868744938873912, 0.5785470209416631, 0.6386693073933304, 0.4282420885525635, 0.22616552898226727, 0.22909694113069956, 0.912029733053979, 0.3713828980949484, 0.9573656634848178, 0.20452268345404157, 0.6718667050325263, 0.8476482962066186, 0.24328020833430808, 0.5187342625346325, 0.23193413108683258, 0.47151622507746227, 0.6124764527742227, 0.2537824681668992, 0.41268869750134884, 0.28086810498820325]

        found_correct_state = False
        for recovered_math_random in recover_state_from_math_random_scaled_values(known_values, factor, translation):
            # Verify that the state generates the correct integers
            for d in known_values:
                self.assertEqual(math.floor(factor * recovered_math_random.next() + translation), d)
            # Check if it generates the expected next doubles
            found_correct_state = all(d == recovered_math_random.next() for d in expected_next)
            if found_correct_state:
                break
        self.assertTrue(found_correct_state)

    def test_recover_state_from_math_random_approximate_values(self):
        generated_doubles = [0.7909911741689747, 0.8514657413496938, 0.4439369897047407, 0.4915718834590873, 0.13826002883337962, 0.8000790562426907, 0.1757029012338981, 0.708534280438173, 0.37443492108086396, 0.20115230687717556]

        # Assume we only know an approximation of each value
        approx_values = [round(d, 5) for d in generated_doubles]
        # And we can bound each value
        bounds = [(v-0.00001, v+0.00001) for v in approx_values]
        
        expected_next = [0.832869258510279, 0.8811329639752462, 0.8361813885437983, 0.0980735041763866, 0.5651374308947414, 0.851033367410471, 0.0016466719576158084, 0.4114342559570725, 0.7070033390886351, 0.8849320705765845, 0.09560183345039053, 0.29098304386949525, 0.09627202648312383, 0.07653847395109004, 0.15589441956758654, 0.812797652737907, 0.6466098215668196, 0.7687984338635581, 0.7755099124044598, 0.8821110593165641, 0.8755463098460196, 0.5567850542588358, 0.6973371338938418, 0.9712743482826413, 0.4142153412901831, 0.23078985965214704, 0.15529888443152717, 0.6453405292152657, 0.2014977565881514, 0.7337569210056293, 0.3408945645328212, 0.247649887558837, 0.29792393948750584, 0.09493177170963008, 0.8257148896444417, 0.8480777825256663, 0.40463775619885634, 0.3484256689817232, 0.5189281378340919, 0.8779626177426069, 0.47858656878592154, 0.14748951770727114, 0.37811747171707977, 0.9802528321677846, 0.1917359433869127, 0.6302420397763413, 0.5462325939874954, 0.9023432491768382, 0.15661481266908717, 0.18368719608116402, 0.8702267230671159, 0.9956011842567898, 0.25909035014634685, 0.39645801202662223, 0.16323042609395266, 0.1470684302355293, 0.8690796876675885, 0.10713134739273344, 0.5467303166625644, 0.6446643125136784, 0.9724278254710444, 0.7121294642412068, 0.3437440512946155, 0.37266001051344466, 0.9343849307240706, 0.30845689709920066, 0.0016914166814636644, 0.07050578137082142, 0.26429895395155556, 0.2167624714059292, 0.5882329802315368, 0.46527371880015134, 0.538418103184017, 0.8484569974205872, 0.6649316525315724, 0.34641089087168275, 0.9202104923388447, 0.558577327876703, 0.9454254617072873, 0.007762132687332168, 0.9088995583989011, 0.7295464666438887, 0.03317193411197106, 0.4917729866482916, 0.04021447888661822, 0.6258812954589608, 0.6281160166233543, 0.12949027206140085, 0.2448463138499607, 0.483657049176175, 0.8788222845261114, 0.5835504598386492, 0.3479085175956548, 0.8480525116511206, 0.8237154869533817, 0.6622618000529038, 0.8947612784574471, 0.6223522219019176, 0.09849707941303143, 0.7981554615376663]

        found_correct_state = False
        for recovered_math_random in recover_state_from_math_random_approximate_values(bounds):
            # Skip the approximate values
            for d in bounds:
                recovered_math_random.next()
            # Check if it generates the expected next doubles
            found_correct_state = all(d == recovered_math_random.next() for d in expected_next)
            if found_correct_state:
                break
        self.assertTrue(found_correct_state)

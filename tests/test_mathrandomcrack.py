import math
import logging
import unittest

from mathrandomcrack.mathrandomcrack import *

logging.basicConfig(level=logging.ERROR)

class TestMathRandomCrack(unittest.TestCase):

    def test_recover_state_from_math_random_doubles(self):
        known_doubles = [0.5167222737819601, 0.6051313728404477, 0.22425498430450674, 0.23438544548454465]

        expected_next = [0.24058273108448502, 0.7071632987915342, 0.7364176754416083, 0.9429174628720893, 0.14463954087461772, 0.46690388204928257, 0.5679465252410643, 0.057808030482194184, 0.7653512491099053, 0.4423105204008999, 0.32394431542177426, 0.17430067774632363, 0.9162234761704138, 0.8614924077878654, 0.5725599101643395, 0.8358935843656736, 0.8739140745431142, 0.41428022100362094, 0.9575789275498869, 0.3259361741900366, 0.0864629375015884, 0.5795087595623722, 0.7197928699840308, 0.6150494448029389, 0.24357820834222532, 0.9718673657131978, 0.5664468219431693, 0.3997006489009376, 0.03347361076455235, 0.7903391889138744, 0.7467833151736378, 0.800893869472477, 0.24504355181355342, 0.10085462519361887, 0.8235361528239129, 0.01680371878229936, 0.29965372111482247, 0.09540919242087664, 0.5663426835696472, 0.6341077288449175, 0.6754921219583394, 0.30087104613638327, 0.4777391681664256, 0.7582024286119369, 0.1314148427639732, 0.8823140870714286, 0.10107145907477744, 0.8063030496288934, 0.5042257712387552, 0.6276445313423586, 0.8170427012084529, 0.1770422890956982, 0.7742555412968606, 0.8633456483429791, 0.6380389595418361, 0.40035320454454504, 0.008949968676235542, 0.5448286455627345, 0.7466638340091585, 0.1886293907130161, 0.3032947493696152, 0.5768133319298463, 0.8532588502311245, 0.8787744833141198, 0.7394620812648265, 0.44394709733857196, 0.2280429557622825, 0.15499131959613877, 0.7241390518277382, 0.10811525833845659, 0.9268626345052817, 0.15829442368373758, 0.31919551378468536, 0.6080300865704606, 0.9535055449405643, 0.41837775923674436, 0.20529957653515907, 0.5820495833564865, 0.25813566316138203, 0.5578002156099406, 0.9760324009766301, 0.3859601122545602, 0.9358865565246022, 0.09853906388451228, 0.12817666982264497, 0.7512422770823941, 0.82639100545096, 0.8191270541527997, 0.29666427234430404, 0.989096451298557, 0.5851415558951292, 0.9193124192070301, 0.5663716711248832, 0.8750940093952984, 0.5275379381911538, 0.42702246194673, 0.7504828173008533, 0.5896473209096103, 0.9618747983218028, 0.7777330464887067]

        found_correct_state = False
        for recovered_math_random in recover_state_from_math_random_doubles(known_doubles):
            # Verify that the state generates the correct doubles
            for d in known_doubles:
                self.assertEqual(recovered_math_random.next(), d)
            # Check if it generates the expected next doubles
            found_correct_state = all(d == recovered_math_random.next() for d in expected_next)
            if found_correct_state:
                break
        self.assertTrue(found_correct_state)

    def test_recover_state_from_math_random_doubles_scattered(self):
        generated_doubles = [0.9317818247293228, 0.10390550168686419, 0.07305787812831155, 0.8899228479633123, 0.9678643972867931, 0.8923801111068459, 0.9981769231353597, 0.01952923788544858, 0.6422523703031464, 0.3680624955677494]

        # Assume we only know some of the generated values and their position
        positions = [0, 4, 5, 9]
        known_doubles = [generated_doubles[pos] for pos in positions]

        expected_next = [0.8764995458510205, 0.531666065682733, 0.37750715273883495, 0.8562629292145478, 0.8442254530076962, 0.6985721224895804, 0.32141914614843325, 0.4816754589892047, 0.5626628068515391, 0.7406806158123047, 0.8467934081871875, 0.9125081956160326, 0.7707821075104102, 0.8772501704965749, 0.4132587071686529, 0.13110848180112722, 0.43181087393905404, 0.41436602409652856, 0.9462215856826626, 0.15478226529368255, 0.6028931513192419, 0.2482298027086367, 0.9118671774280918, 0.10927436361601828, 0.866819880638716, 0.034044838819265344, 0.4747242540309755, 0.8429812970517292, 0.8417182533023033, 0.15344943478556838, 0.32376225423789085, 0.5240914763426343, 0.0787777606790554, 0.509486444494323, 0.8300917459561967, 0.5261785762247104, 0.9506889140815769, 0.5739732865407203, 0.4274745047468431, 0.20866987617419563, 0.1469697345064096, 0.7326535785023955, 0.8512207604821072, 0.019447255233857152, 0.0940586053906376, 0.45788638751812893, 0.14944842990056806, 0.7816096075947794, 0.4803245759743189, 0.2644015482193578, 0.4371772216174523, 0.9092153033839947, 0.8118088585224121, 0.13822150437510072, 0.13323543158737516, 0.17925562551404162, 0.2757268293899715, 0.6868651828916292, 0.31912335424937677, 0.8571641617656351, 0.7057941250743915, 0.9664930816176194, 0.2012105510808797, 0.5414774783143428, 0.16710324020067402, 0.8342887711671767, 0.3812208887662982, 0.9427435679461424, 0.8964666676448301, 0.36817065366101187, 0.6647610743878958, 0.5579445933556737, 0.9846596535827048, 0.7350555429792642, 0.03628829561818159, 0.1417507609279809, 0.7530182515150505, 0.7302586280243459, 0.8349375350112285, 0.6651053154058528, 0.6812861941632109, 0.3949772572116985, 0.39139541205059625, 0.691223227352157, 0.3000285141328991, 0.2812374512540796, 0.858307935551369, 0.11213558956224112, 0.1391606203662754, 0.211241130264322, 0.8114566626181039, 0.4288525080214811, 0.7268366927227243, 0.5914029184477438, 0.7819026584566435, 0.27544142017644124, 0.6053317880119988, 0.4429720254022509, 0.30984337849085297, 0.7737307511930631]
        
        found_correct_state = False
        for recovered_math_random in recover_state_from_math_random_doubles(known_doubles, positions):
            # Verify that the state generates the correct doubles
            for d in generated_doubles:
                self.assertEqual(recovered_math_random.next(), d)
            # Check if it generates the expected next doubles
            found_correct_state = all(d == recovered_math_random.next() for d in expected_next)
            if found_correct_state:
                break
        self.assertTrue(found_correct_state)

    def test_recover_state_from_math_random_scaled_values(self):
        factor = 36
        translation = 1
        known_values = [3, 25, 9, 29, 36, 35, 18, 5, 31, 21, 35, 34, 23, 6, 11, 9, 14, 10, 26, 36, 6, 19, 22, 26, 28, 6, 25, 30, 9, 35, 25, 2, 15, 5, 11, 3, 20, 15, 29]

        expected_next = [0.7209458431367699, 0.8985822881713079, 0.21186332810991826, 0.28214974331660025, 0.2502726605593646, 0.3135672027399179, 0.5262910830481775, 0.9172659200547224, 0.24325374615573003, 0.02065930602400967, 0.8302650374829408, 0.14023112605279153, 0.07548080581340089, 0.5077821841887347, 0.47283314711131674, 0.30203672761797207, 0.6796096086676449, 0.2760700760488064, 0.6771133272001981, 0.9106156839509514, 0.5165127219868215, 0.4078742290411499, 0.04674743472340337, 0.7716050921481585, 0.2787314100039324, 0.8080574627993238, 0.3400186144519548, 0.959860017724175, 0.361983417578301, 0.31356441664324763, 0.3640730762214359, 0.3278801881712585, 0.746344887557612, 0.050154671147710994, 0.7236855079058224, 0.8641822825571657, 0.4464360578893496, 0.7274245122871963, 0.9946000831835453, 0.4129778356849161, 0.5232599666238447, 0.015848307203121248, 0.6538721502849234, 0.3977099390368162, 0.214388722710676, 0.981900412792176, 0.10945925942017687, 0.6715140699825337, 0.5829441709617145, 0.04266562510692018, 0.3763036725628568, 0.40279424825893373, 0.048174148014014984, 0.9728570665570155, 0.8077780285729959, 0.02338089897957385, 0.11758432778268091, 0.18421735838382114, 0.4168923327446512, 0.3052834326927474, 0.8653910127835263, 0.6907520459356267, 0.735217311143789, 0.7687854506894649, 0.09357076093931926, 0.2059794550298697, 0.8007237835326704, 0.39630968738466676, 0.2993944758454741, 0.9299164749072979, 0.4864824852562646, 0.7245536055289479, 0.8415869560632891, 0.23684422051795107, 0.8591671214125611, 0.4907093768940769, 0.7227010873318864, 0.12413726530717528, 0.4171509500878403, 0.8136863285919274, 0.4522589190177668, 0.18184060465097285, 0.17535512972627565, 0.9902788400284039, 0.4247485091232399, 0.41068040957300367, 0.8764265653507519, 0.7284125327248521, 0.4651835175212311, 0.05894503112376315, 0.6234565859697629, 0.7674212851419249, 0.7740838070259854, 0.9829970570177939, 0.39734331901080466, 0.39665257725336023, 0.6149550217069082, 0.4900068666754547, 0.38871938158953245, 0.6122842441776328]

        found_correct_state = False
        for recovered_math_random in recover_state_from_math_random_scaled_values(known_values, factor, translation):
            # Verify that the state generates the correct integers
            for d in known_values:
                self.assertEqual(math.floor(factor * recovered_math_random.next() + translation), d)
            # Check if it generates the expected next doubles
            found_correct_state = all(d == recovered_math_random.next() for d in expected_next)
            if found_correct_state:
                break
        self.assertTrue(found_correct_state)

    def test_recover_state_from_math_random_approximate_values(self):
        generated_doubles = [0.5019992703037597, 0.667980064435663, 0.07567527557849352, 0.5222288658540033, 0.7684859420779444, 0.9135964703361965, 0.9103127440036822, 0.4334395444581125, 0.8444821088635026, 0.7073512095061945]

        # Assume we only know an approximation of each value
        approx_values = [round(d, 5) for d in generated_doubles]
        # And we can bound each value
        bounds = [(v-0.00001, v+0.00001) for v in approx_values]
        
        expected_next = [0.4270253183399009, 0.057646016832219704, 0.24063414442436293, 0.03904549311027283, 0.7340896798005367, 0.6133653144760614, 0.43270650886738693, 0.36350854430705515, 0.9315981705259553, 0.10111435249776113, 0.3275954296162127, 0.5486211508061885, 0.8178756305988426, 0.35189295142417, 0.16943128414727204, 0.8063749965019624, 0.29475673207356423, 0.09782011623842024, 0.6869457949143554, 0.24840254023368802, 0.08460825956042428, 0.2880044446884664, 0.8117922040473284, 0.39590583890346753, 0.4206912225230768, 0.9545314287321591, 0.18403633728131896, 0.6807396956823184, 0.3513845022205311, 0.9768699471114568, 0.4733564680459623, 0.5415848538337558, 0.7874893220436134, 0.7005367206508464, 0.034715467215564066, 0.580570481290767, 7.553225422540777e-05, 0.14154156325261846, 0.39334729339061014, 0.6211442796285809, 0.16731343483177863, 0.17948574952037988, 0.8976952894164667, 0.8690630301263338, 0.004534748667740285, 0.38765153122691154, 0.8809286968620078, 0.1018945689650661, 0.6306753581789428, 0.9484554872243829, 0.3694722713764793, 0.784862565205575, 0.0848593133275759, 0.3830220398235873, 0.016718680016277743, 0.9916500577653802, 0.21147344248317324, 0.2730276054255558, 0.6288630753900777, 0.8154320967593267, 0.7228886825942058, 0.2814043917555398, 0.11948727796683012, 0.1174918751047489, 0.6364080470209947, 0.38282476317682934, 0.5251989809599933, 0.3273244838012179, 0.14140795988325294, 0.4484549785066714, 0.6561027695585111, 0.10642800387925, 0.1564229227434395, 0.6300526347453115, 0.8976294307708084, 0.5867159155660184, 0.598335852302124, 0.9938064745903448, 0.9706978347258297, 0.8669493030281383, 0.38480177850130515, 0.28049623628063647, 0.5559773049759726, 0.3744326337485644, 0.12789868619399614, 0.02313762649147222, 0.7960139431928352, 0.7740165032707587, 0.14540721888452413, 0.9646400315365178, 0.47051783451841045, 0.8878818069588517, 0.4718760121385508, 0.9349738903599285, 0.919211684157859, 0.7180964592229151, 0.601766082707673, 0.859642141400256, 0.8262308340620768, 0.20376482407247387]

        found_correct_state = False
        for recovered_math_random in recover_state_from_math_random_approximate_values(bounds):
            # Skip the approximate values
            for d in bounds:
                recovered_math_random.next()
            # Check if it generates the expected next doubles
            found_correct_state = all(d == recovered_math_random.next() for d in expected_next)
            if found_correct_state:
                break
        self.assertTrue(found_correct_state)
